## 栈

### 1栈的基本概念和性质
> 栈是限定仅在表头进行插入和删除操作的线性表。  

它是后进先出（LIFO）的。对栈的基本操作只有push（进栈）和pop（出栈）两种，前者相当于插入，后者相当于删除最后的元素。上篇文章讲递归的有讲到，程序在运行时，如果调用一个函数，则将该函数压栈（push），调用完一个函数则出栈（pop）。递归过程中，不断的压栈(因为该函数并没有执行完毕，因为还没有执行到函数的最后一个大括号 } )。因为内存是有限的，因此会造成栈溢出。  


由于栈在本质上是一种受限制的表，所以可以使用任何一种表的形式来实现它，我们最常用的一般有两种：  
（1）顺序栈：数组  
（2）链式栈：链表  
### 2.栈ADT及其顺序实现
其中又分为静态数组和动态数组两类。  
- 静态数组：特点是要求结构的长度固定，而且长度在编译时候就得确定。其优点是结构简单，实现起来方便而不容易出错。而缺点就是不够灵活以及固定长度不容易控制，适用于知道明确长度的场合。
- 动态数组：特点是长度可以在运行时候才确定以及可以更改原来数组的长度。优点是灵活，缺点是由此会增加程序的复杂性。

### 3. 链接实现

>由于只有堆栈顶部元素才可以被访问，因此使用单链表可以很好实现链式堆栈，而且无长度限制。把一个新元素压入堆栈是通过在链表的起始位置添加一个元素实现的。从堆栈中弹出一个元素是通过从链表中移除第 1 个元素实现的。位与链表头部的元素总是很容易被访问。由于没有长度限制，故不需要create_stack函数，但可以实现destroy_stack函数用于清空堆栈。由于用于存储元素的内存是动态分配的，它必须予以释放以避免内存泄漏。  

```c++

/*  栈类型的头文件  */    
  
  
#ifndef STACK_H_  
#define STACK_H_   
  
  
    struct Node;                                    //先声明，就可以在下面使用，而不必因定义在后面而产生冲突  
    
    
    /*  一般类型定义  */    
    typedef int ElementType;                        //抽象数据类型    
    typedef struct Node * PtrToNode;  
    typedef PtrToNode Stack;  
    
    
    
    /*  特定于程序的声明  */     
    struct Node {  
        ElementType element;    
        PtrToNode	next;  
    };  
    
    
    /*  函数原型  */    
    void MakeEmpty ( Stack s );  
    int IsEmpty ( Stack s );
    void Push ( ElementType x, Stack s );  
    void Pop ( Stack s );  
    Stack CreateStack ( void );
    void DisposeStack ( Stack s );
    ElementType Top ( Stack s );
  
#endif  
```



### 4.顺序数组和链式实现 两者做对比
它们在复杂度上的优缺点对比如下：
1、新增和删除元素时的时间复杂度
链表：在动态申请内存（new或者malloc）上的花销非常昂贵。
数组：几乎没有花销，以常数 O(1) 时间运行，在带有自增和自减寻址功能的寄存器上操作时，编译器会把整数的 push 和 pop 操作编译成一条机器指令。
2、空间复杂度
链表：由于空间是动态申请、释放的，因此不会浪费空间，而且只要物理存储器允许，理论上能够满足最大范围未知的情况。
数组：必须在初始化时执行栈的大小，有可能会浪费空间，也有可能不够空间用。
结论：
（1）如果对运动时的效率要求非常高，并且能够在初始化时预知栈的大小，那么应该首选数组形式，否则应该选用链表形式。
（2）由于对栈的操作永远都是针对栈顶（top）进行的，因此数组的随机存取的优点就没有了，而且数组必须预先分配空间，空间大小也受到限制，所以一般情况下（对运行时效的要求不是太高）链表应该是首选。

## 5. 栈的应用


## 6. 栈和递归
