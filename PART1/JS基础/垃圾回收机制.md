## Javascript的垃圾回收

### 什么是垃圾回收
> 在代码执行过程中，声明一个变量，定义一个函数都会占用内存。内存容量是有限的，如果只占不清，内存迟早会被完全占用。就像地球上的人，如果只增不减，地球就会容不下我们。所以这时候就需要垃圾回，找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。

--- 

### 为什么要垃圾回收
程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。

机器的内存是有限的。

对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

    这里区分两个概念：
        - 内存泄漏 Memory Leak
        - 内存溢出 Out of Memory  


    *内存泄漏*  
    内存泄漏是申请的空间没有及时释放或者干脆丢了指针没法释放.不是泄漏,是漏不出来;只是泄漏的内存远小于可分配的内存时影响不大,多了就玩完.

    *内存溢出*   
    申请的内存超过了可用内存,内存不够用了

不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。
有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。
这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为"垃圾回收机制"（garbage collector）。

JavaScript就是采用了自动垃圾回收机制。

---

### 如何进行垃圾回收

- 垃圾回收的方式
- 垃圾回收的频率

#### 垃圾回收的方式
    那么javascript是如何知道，是否要将这块内存回收呢？
    主要有两种形式：
    - 引用计数
    - 标记清除

- 引用计数

“引用计数”:语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。
```javascript 
    var a = {p: 1};   //对象{p:1}，以下简称obj,第1次引用
    var b = a;        //obj 第2次引用

    a = null;         // obj引用1次
    b = null;         // obj 应用0次 可以被释放


    var c = [1,2,3,4];
    console.log('数组[1,2,3,4]被引用1次');
    //尽管后面的代码没有用到 c 但是因为有1次引用，所以[1,2,3,4]所占用的内存不会被释放

    // 如果解除对数组的引用，则这块内存将会被释放
    c = null; // c = 1;

    //另外一种是循环引用，如果使用引用计数则会发生永远无法释放的问题
    function test() {
        var a = {a:1};
        var b = {b:1};
        a.b = b;
        b.a = a;
    }

```
因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。

- 标记清除
这是当前主流的GC算法，V8里面就是用这种。当对象，无法从根对象沿着引用遍历到，即不可达（unreachable），进行清除。对于上面的例子，fn() 里面的 a 和 b 在函数执行完毕后，就不能通过外面的上下文进行访问了，所以就可以清除了。

也就是说，在局部作用域内的变量，在作用域内有效,作用域结束后自动被收回。
但是有一个比较特殊，就是我们之后要讲的闭包。

---

#### 垃圾回收的频率
没种方式的频率都不尽相同，下面以V8的回收机制为例：
在大部分的应用场景：一个新创建的对象，生命周期通常很短。所以，V8里面，GC处理分为两大类：新生代和老生代。

新生代的堆空间为1M~8M，而且被平分成两份（to-space和from-space），通常一个新创建的对象，内存被分配在新生代。当to-space满的时候，to-space和form-space交换位置（此时，to空，from满），并执行GC.如果一个对象被断定为，未被引用，就清除；有被引用，逃逸次数+1（如果此时逃逸次数为2，就移入老生代，否则移入to-space）。

老生代的堆空间大，GC不适合像新生代那样，用平分成两个space这种空间换时间的方式。老生代的垃圾回收，分两个阶段：标记、清理（有Sweeping和Compacting这两种方式）。

标记，采用3色标记：黑、白、灰。步骤如下：

1. GC开始，所以对象标记为白色。
1. 根对象标记为黑色，并开始遍历其子节点（引用的对象）。
1. 当前被遍历的节点，标记为灰色，被放入一个叫 marking bitmap 的栈。在栈中，把当前被遍历的节点，标记为黑色，并出栈，同时，把它的子节点（如果有的话）标记为灰色，并压入栈。（大对象比较特殊，这里不展开）
1. 当所有对象被遍历完后，就只剩下黑和白。通过Sweeping或Compacting的方式，清理掉白色，完成GC。

小补充：JavaScript的根对象
GC的时候，从根对象开始遍历。在浏览器，根对象是 window；在 Node.js 中，是 global（或称为root）.

Node.js中，每个文件被当做一个模块，所以，当你用 var/let/const 在文件的全局，声明变量的时候，作用域是当前文件（模块）。



### 良好实践——为了避免内存泄漏，我们需要注意什么
1. 优化内存的一个最好的衡量方式就是只保留程序运行时需要的数据，对于已经使用的或者不需要的数据，应该将其值设为 null，这上面说过，叫“解除引用”。需要注意的是，解除一个值的引用不代表垃圾回收器会立即将这段内存回收，这样做的目的是让垃圾回收器在下一个回收周期到来时知道这段内存需要回收。

在内存泄漏部分，我们讨论了无意的全局变量会带来无法回收的内存垃圾。但有些时候，我们会有意识地声明一些全局变量，这个时候需要注意，如果声明的变量占用大量的内存，那么在使用完后将变量声明为 null。

2. 减少内存垃圾的另一个方法就是避免创建对象。new Object() 是一个比较明显的创建对象的方式，另外 const arr = [];、const obj = {};也会创建新的对象。另外下面这种写法在每次调用函数时都会创建一个新的对象：

function func() {
    return function() {};
}
另外，当清空一个数组时，我们通常的做法是 array = []，但这种做法的背后是新建了一个新的数组然后将原来的数组当作内存垃圾。建议的做法是 array.length = 0，这样做不仅可以重用原来的变量，而且还避免创建了新的数组。

​
#### 内存泄漏
在谈什么是良好实践（这里指有益于内存管理）之后，再谈谈内存泄漏，也就是差的实践。内存泄漏是指计算机可用的内存越来越少，主要是因为程序不能释放那些不再使用的内存。

##### 循环引用
这个没什么好说的，上面已经介绍了。

需要强调的一点就是，一旦数据不再使用，最好通过将其值设为 null 来释放其引用，这个方法被称为“解除引用”。

#### 无意的全局变量
```javascript
function foo(arg) {
    const bar = "";
}

foo();
```
当 foo 函数执行后，变量 bar 就会被标记为可回收。因为当函数执行时，函数创造了一个作用域来让函数里的变量在里面声明。进入这个作用域后，浏览器就会为变量 bar 创建一个内存空间。当这个函数结束后，其所创建的作用域里的变量也会被标记为垃圾，在下一个垃圾回收周期到来时，这些变量将会被回收。

但事情并不会那么顺利。
```javascript
function foo(arg) {
    bar = "";
}

foo();
```
上面的代码就无意中声明了一个全局变量，会得到 window 的引用，bar 实际上是 window.bar，它的作用域在 window 上，所以 foo 函数执行结束后，bar 也不会被内存收回。

另外一种无意的全局变量的情况是：
```javascript
function foo() {
    this.bar = "";
}
```
在 foo 函数中，this 指的是 window（详细内容可参见我的另一篇博客：JavaScript this 讲解），犯的错误跟上面类似。

#### 被遗忘的计时器和回调函数
```javascript
let someResource = getData();
setInterval(() => {
    const node = document.getElementById('Node');
    if(node) {
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);
```
上面的例子中，我们每隔一秒就将得到的数据放入到文档节点中去。但在 setInterval 没有结束前，回调函数里的变量以及回调函数本身都无法被回收。那什么才叫结束呢？就是调用了 clearInterval。如果回调函数内没有做什么事情，并且也没有被 clear 掉的话，就会造成内存泄漏。不仅如此，如果回调函数没有被回收，那么回调函数内依赖的变量也没法被回收。上面的例子中，someResource 就没法被回收。同样的，setTiemout 也会有同样的问题。所以，当不需要 interval 或者 timeout 时，最好调用 clearInterval 或者 clearTimeout。

#### DOM
在 IE8 以下的版本里，DOM 对象经常会跟 JavaScript 之间产生循环引用。看一个例子：
```javascript
function setHandler() {
    const ele = document.getElementById('id');
    ele.onclick = function() {};
}
```
在这个例子中，DOM 对象通过 onclick 引用了一个函数，然而这个函数通过外部的词法环境引用了这个 DOM 对象，形成了循环引用。不过现在不必担心，因为所有现代浏览器都采用了标记－整理方法，避免了循环引用的问题。

除了这种情况，我们现在还会在其他时候在使用 DOM 时出现内存泄漏的问题。当我们需要多次访问同一个 DOM 元素时，一个好的做法是将 DOM 元素用一个变量存储在内存中，因为访问 DOM 的效率一般比较低，应该避免频繁地反问 DOM 元素。所以我们会这样写：
```javascript
    const button = document.getElementById('button');
```
当删除这个按钮时：
```javascript
document.body.removeChild(document.getElementById('button'));
```
虽然这样看起来删除了这个 DOM 元素，但这个 DOM 元素仍然被 button 这个变量引用，所以在内存上，这个 DOM 元素是没法被回收的。所以在使用结束后，还需要将 button 设成 null。

另外一个值得注意的是，代码中保存了一个列表 ul 的某一项 li 的引用，将来决定删除整个列表时，我们自觉上会认为内存仅仅会保留那个特定的 li，而将其他列表项都删除。但事实并非如此，因为 li 是 ul 的子元素，子元素与父元素是引用关系，所以如果代码保存 li 的引用，那么整个 ul 将会继续呆在内存里。

#### 数组array优化

　　将[]赋值给一个数组对象，是清空数组的捷径（例如： arr = [];），但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。

#### 方法function优化

　　方法一般都是在初始化的时候创建，并且此后很少在运行时进行动态内存分配，这就使得导致内存垃圾产生的方法，找起来就不是那么容易了。但是从另一角度来说，这更便于我们寻找了，因为只要是动态创建方法的地方，就有可能产生内存垃圾。例如：将方法作为返回值，就是一个动态创建方法的实例。

　　在游戏的主循环中，setTimeout或requestAnimationFrame来调用一个成员方法是很常见的，例如：
```javascript
setTimeout(
    (function(self) {                    
      return function () {
              self.tick();
    };
})(this), 16)
```
　　每过16毫秒调用一次this.tick()，嗯，乍一看似乎没什么问题，但是仔细一琢磨，每一次调用都返回了一个新的方法对象，这就导致了大量的方法对象垃圾！

　　为了解决这个问题，可以将作为返回值的方法保存起来，例如：
```javascript
// at startup
this.tickFunc = (
    function(self) {
      return function() {
                self.tick();
      };
    }
)(this);

// in the tick() function
setTimeout(this.tickFunc, 16);
```
　　相比于每次都新建一个方法对象，这种方式在每一帧当中重用了相同的方法对象。这种方式的优势是显而易见的，而这种思想也可以应用在任何以方法为返回值或者在运行时创建方法的情况当中。






