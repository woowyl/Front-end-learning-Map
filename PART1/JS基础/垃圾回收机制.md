## Javascript的垃圾回收

### 什么是垃圾回收
> 找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。

--- 

### 为什么要垃圾回收
程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。

机器的内存是有限的。

对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

        这里区分两个概念：
            - 内存泄漏 Memory Leak
            - 内存溢出 Out of Memory

        *内存泄漏*  
        内存泄漏是申请的空间没有及时释放或者干脆丢了指针没法释放.不是泄漏,是漏不出来;只是泄漏的内存远小于可分配的内存时影响不大,多了就玩完.

        *内存溢出*   
        申请的内存超过了可用内存,内存不够用了

不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。
有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。
这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为"垃圾回收机制"（garbage collector）。

JavaScript就是采用了自动垃圾回收机制。

---

### 如何进行垃圾回收

#### 垃圾回收的方式
    那么javascript是如何知道，是否要将这块内存回收呢？
    主要有两种形式：
    - 引用计数
    - 标记清除

- 引用计数

“引用计数”:语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。
```javascript 
    var a = {p: 1};   //对象{p:1}，以下简称obj,第1次引用
    var b = a;        //obj 第2次引用

    a = null;         // obj引用1次
    b = null;         // obj 应用0次 可以被释放


    var c = [1,2,3,4];
    console.log('数组[1,2,3,4]被引用1次');
    //尽管后面的代码没有用到 c 但是因为有1次引用，所以[1,2,3,4]所占用的内存不会被释放

    // 如果解除对数组的引用，则这块内存将会被释放
    c = null; // c = 1;

    //另外一种是循环引用，如果使用引用计数则会发生永远无法释放的问题
    function test() {
        var a = {a:1};
        var b = {b:1};
        a.b = b;
        b.a = a;
    }

```
因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。

- 标记清除
这是当前主流的GC算法，V8里面就是用这种。当对象，无法从根对象沿着引用遍历到，即不可达（unreachable），进行清除。对于上面的例子，fn() 里面的 a 和 b 在函数执行完毕后，就不能通过外面的上下文进行访问了，所以就可以清除了。

也就是说，在局部作用域内的变量，在作用域内有效,作用域结束后自动被收回。
但是有一个比较特殊，就是我们之后要讲的闭包。

---

#### 垃圾回收的频率
没种方式的频率都不尽相同，下面以V8的回收机制为例：
在大部分的应用场景：一个新创建的对象，生命周期通常很短。所以，V8里面，GC处理分为两大类：新生代和老生代。

新生代的堆空间为1M~8M，而且被平分成两份（to-space和from-space），通常一个新创建的对象，内存被分配在新生代。当to-space满的时候，to-space和form-space交换位置（此时，to空，from满），并执行GC.如果一个对象被断定为，未被引用，就清除；有被引用，逃逸次数+1（如果此时逃逸次数为2，就移入老生代，否则移入to-space）。

老生代的堆空间大，GC不适合像新生代那样，用平分成两个space这种空间换时间的方式。老生代的垃圾回收，分两个阶段：标记、清理（有Sweeping和Compacting这两种方式）。

标记，采用3色标记：黑、白、灰。步骤如下：

1. GC开始，所以对象标记为白色。
1. 根对象标记为黑色，并开始遍历其子节点（引用的对象）。
1. 当前被遍历的节点，标记为灰色，被放入一个叫 marking bitmap 的栈。在栈中，把当前被遍历的节点，标记为黑色，并出栈，同时，把它的子节点（如果有的话）标记为灰色，并压入栈。（大对象比较特殊，这里不展开）
1. 当所有对象被遍历完后，就只剩下黑和白。通过Sweeping或Compacting的方式，清理掉白色，完成GC。

小补充：JavaScript的根对象
GC的时候，从根对象开始遍历。在浏览器，根对象是 window；在 Node.js 中，是 global（或称为root）.

Node.js中，每个文件被当做一个模块，所以，当你用 var/let/const 在文件的全局，声明变量的时候，作用域是当前文件（模块）。


### 为了避免内存泄漏，我们需要注意什么





