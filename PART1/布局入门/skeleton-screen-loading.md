# skeleton 实现

## 我们什么时候需要骨架屏幕

从浏览器渲染的角度来看，1. 用户发送了一个请求 ——> 2.服务器端收到这个请求(2.5 处理合成html) ——> 3.服务器返回html  ——> 4. 浏览器解析CSS ——> 5.浏览器渲染HTML ——> 6.浏览器执行JS ——> 7.调取接口，拿到数据，重新渲染页面

### 骨架屏的类型：

1. 初始化骨架屏
2. 页面内接口获取的骨架屏

### 骨架屏在初始页面帮我们解决了哪些时间：

1. 如果我们采用PHP渲染的方式  
    php渲染+vanish缓存，由于页面需要在
2. 如果我们采用前端端分离的方式  
    节省了`2.5`、`6`、`7`的过程，如果再加上vanish缓存，而且由于页面不依赖数据（数据通过接口获取），vanish缓存的命中率更高，当同类页面再次进入时，由于vanish的存在基本上可获取类原生的速度。

综上，只有在前后端分离的页面里，初始化骨架屏才有意义，而且骨架屏不应依赖任何框架，依赖框架，则意味着 骨架屏的时间要在`6`这个过程之后。

### 骨架屏在接口调取过程中的作用

- 在接口调取过程则可以使用框架，因为在这个过程中，页面已加载了Vue Jquery这样的框架。

### 怎么去做

1. 用图，自适应不太好

2. 从实现的角度来看，要做到上图的效果，我们需要对现有页面做两点操作：
    1. 创建与页面加载完毕后显示内容相似的 HTML 结构
    2. 在需要显示的内容元素上增加背景色（以及 loading 动画）

### 问题在哪儿

1. 代码侵入式，同一个样式，需要维护两处（一个骨架屏，一个真实样式），设想如果每次真实组件有迭代，那么我们都需要手动去同步每一个变化到 Skeleton Screen 结构上的话，那实在是太繁琐了
    - 咨询饿了么的实现方式和支付宝的实现方式
    - 写一套代码通过webpack 去打包生成不同的两个样式
    - 服务器端渲染
    - `:empty`适合jquery类赋值

2. 服务器端渲染