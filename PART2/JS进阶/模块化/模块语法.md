# 几种常见的模块化
## 1、 ES6 —— 编译时  
模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。  

一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。

### - 1.1 export

```javascript
    //一种形式
    export var firstName = 'Michael';
    export var lastName = 'Jackson';
    export var year = 1958

    // 另一种形式 (比第一种好，推荐)
    var firstName = 'Michael';
    var lastName = 'Jackson';
    var year = 1958;

    export {firstName, lastName, year}

    // 输出函数或类
    export function multiply(x, y) {
        return x * y;
    }

    // 给输出起别名
    function v1() { ... }
    function v2() { ... }

    export {
        v1 as streamV1,
        v2 as streamV2,
        v2 as streamLatestVersion
    };
```
`export`命令规定的是对外的接口，必须与模块内部的变量建立一一对应的关系。
常见的错误使用：
``` javascript
// 报错
export 1;

// 报错
var m = 1;
export m;

/*----- 正确写法-------*/
// 写法一
export var m = 1;
// 写法二
var m = 1;
export {m};
// 写法三
var n = 1;
export {n as m};
```

export命令可以出现在模块的任何位置，只要处于模块顶层就可以


### - 1.2 import  
使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。

```javascript
    // main.js
    import {firstName, lastName, year} from './profile.js';

    function setName(element) {
        element.textContent = firstName + ' ' + lastName;
    }


    // 可以使用别名
    import { lastName as surname } from './profile.js';
```
import命令输入的变量都是`只读`的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。

``` javascript
    import {a} from './xxx.js'
    //!!!! wrong wrong
    a = {}; //    Syntax Error : 'a' is read-only;

    //!!!! 允许
    a.foo = "hello";
```

import语句会执行所加载的模块，因此可以有下面的写法。
```javascript
    import 'lodash';
```
上面代码仅仅执行lodash模块，但是不输入任何值。

### - 1.3 整体加载*
``` javascript
    import { area, circumference } from './circle';

    console.log('圆面积：' + area(4));
    console.log('圆周长：' + circumference(14));

    // 以上写法等价于
    import * as circle from './circle';

    console.log('圆面积：' + circle.area(4));
    console.log('圆周长：' + circle.circumference(14));

```
模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。

```javascript
    import * as circle from './circle';
    // 任何的修改都是不许的
    // 下面两行都是不允许的
    circle.foo = 'hello';
    circle.area = function () {};

```
### -1.4 export default
在实际的开发中，我们不可能去指定每个模块（也就是文件）export了哪些内容，在使用时，也就不能准确地写出对应名字。考虑到这个问题，而且多数模块主要实现的是一个重点内容，所以就给ES添加了一个export default的属性，就是在不知道加载变量名或函数名的情况下仍然可以正常使用。

定义方式：

```javascript
    // export-default.js
    export default function() {
        console.log('foo');
    }
```
使用方式：
``` javascript
    //customName 是自己想的名字和定义的js内容无关
    import customName from './export-default.js'

    customName();
```

下面比较一下默认输出和正常输出。
``` javascript
    // 第一组
    export default function crc32() { // 输出
        // ...

    }

    import crc32 from 'crc32'; // 输入


    // 第二组
    export function crc32() { // 输出
        // ...

    };

    import {crc32} from 'crc32'; // 输入

```
上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。

### -1.5 export 与 import 的复合写法
如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。
```javascript
    export { foo, bar } from 'my_module';

    // 可以简单理解为
    import { foo, bar } from 'my_module';
    export { foo, bar };
```


2、node.js  COMMONJS —— 运行时

3、外部框架 requireJS(AMD) sea.js(CMD) ——运行时确定

4、微信小程序

